//
// /* ==========================================================================================
//  * SteamshipMarkdownStream
//  *
//  * A SteamshipMarkdownStream emits Markdown containing text, images, audio, and video
//  * generated by an LLM or Multimodal Agent.
//  *
//  * Since Steamship's native data model is to respond to completion requests with a "stream of
//  * multi-modal streams", the SteamshipMarkdownStream wrapper funnels these into a single
//  * text-only stream using Markdown to represent media.
//  *
//  * Video and Audio are embedded as links since Markdown lacks native support for these types.
//  *
//  * =========================================================================================*/
//
// import {createFileEventStreamParser, createFileEventStreamParserFromResponse, FileStreamEvent} from "./file-stream";
// import {SteamshipBlock} from "./datamodel";
// import {StreamQueue} from "./stream-queue";
// import {createMarkdownBlockStreamParserFromBlock} from "./block-stream";
//
// const SteamshipMarkdownStreamFromReader = (
//     reader: ReadableStreamDefaultReader,
//     // callbacks?: AIStreamCallbacksAndOptions
// ): ReadableStream => {
//     // What we ultimately want to return to users is a ReadableStream that outputs Markdown.
//     // That is going to be implemented as a StreamQueue which allows us to append individual BlockStreams as they
//     // are being created.
//     const markdownStream = new StreamQueue<string>();
//
//     // The `reader` object -- the response to our /generate request -- is a SteamshipFileStream that will
//     // stream us events of any Steamship Blocks that are being created as a result of the request.
//     const fileStream = createFileEventStreamParser(reader)
//
//     const onFileStreamEvent = async (event: FileStreamEvent) => {
//         if ((event.event == "BLOCK_APPENDED") && (event.data)) {
//             const block: SteamshipBlock = event.data
//             const blockStream = await createMarkdownBlockStreamParserFromBlock(block);
//             markdownStream.enqueue(blockStream);
//         } else if (event.event == "STREAM_FINISHED") {
//             // Tell the StreamQueue that we're done appending streams.
//             markdownStream.streamAddingClosed = true;
//         }
//     }
//
//     async function consumeLoop() {
//         while (true) {
//             const {done, value} = await reader.read();
//             if (done) {
//                 // Tell the StreamQueue that we're done appending streams.
//                 markdownStream.streamAddingClosed = true;
//                 break;
//             }
//             onFileStreamEvent(value)
//         }
//     }
//
//     // TODO: Test that this return isn't blocked upon the manner of implementation above.
//     return markdownStream.start()
// }
//
// const SteamshipMarkdownStream = (
//     response: Response,
//     // callbacks?: AIStreamCallbacksAndOptions
// ): ReadableStream => {
//     const reader = response.body?.getReader()
//     if (!reader) {
//         throw Error("No body in response.")
//     }
//     return SteamshipMarkdownStreamFromReader(reader)
// }
//
// export {
//     SteamshipMarkdownStream,
//     SteamshipMarkdownStreamFromReader
// }